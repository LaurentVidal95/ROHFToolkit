"""
    One iteration of conjugate gradient algorithm
"""
function CG_step(ΦT, Sm12, A, H, N_bds;
                 atom_info = [],
                 E_previous = zero(Float64),
                 p_previous = zero(Float64),
                 step = zero(Float64),
                 previous_norm_grad_E=zero(Float64),
                 ΦT_previous = zero(ΦT),
                 max_step = one(Float64), ρ = 0.5,
                 restart_cg = true,
                 transport = "proj",
                 linesearch_type = HagerZhang(),
                 )
    
    Nb,Nd,Ns = N_bds; No = Nd+Ns;

    # Compute gradient
    E = energy_from_MOs_T(ΦT, Sm12, A, H, N_bds, atom_info=atom_info)
    ∇E = grad_E_MO_metric(ΦT, Sm12, A, H, N_bds)
    p = .-∇E; square_norm_p = norm(p)^2 

    Φd,Φs = split_MOs(ΦT,N_bds);
    τ_p_prev = (zero(Φd),zero(Φs)) #test
    
    if !(restart_cg) # Compute CG direction if no restart
        @assert(norm(ΦT - ΦT_previous) > 1e-8)
        (transport == "transport") && (τ_p_prev = transport_MOs_same_dirs(p_previous, step, ΦT_previous, ΦT, N_bds))
        (transport == "proj") && (τ_p_prev = proj_horizontal_tangent_space(ΦT, p_previous, N_bds))

        β = square_norm_p/previous_norm_grad_E

        # Next dir
        p = p .+ β .* τ_p_prev
        p = proj_horizontal_tangent_space(ΦT, p, N_bds)
    end

    cos_p_∇E = dot(∇E,p)/(norm(∇E)*norm(p))

    # Armijo linesearch
    step, E, ΦT = line_search(ΦT, p,
                              Sm12, A, H, N_bds, atom_info = atom_info,
                              E = E, ∇E = ∇E,
                              max_step = max_step, ρ=ρ,
                              linesearch_type = linesearch_type,
                              )
    (step == 0) && ( return( (ΦT, p, square_norm_p, E, previous_norm_grad_E,
                              cos_p_∇E, zero(Float64))) )
    ΦT, p, square_norm_p, E, norm(∇E), cos_p_∇E, step
end


"""
    Preocnditionned conjugate gradient on the ROHF manifold.
    The preconditionner is one approximation of the hessian matrix given in 
    [insert doi article] formula (27).
o    
    Parameters are

    <><> General
    - Σ: the chemical system of the computation
    - max_iter: maximum number of CG iterations
    - cv_threshold: convergence threshold on the norm of the projected gradient.
    Should be 0 on a minimum.

    <><> Print and save data
    - verbosity ∈ ("high", "medium", "head", "tail")
        -> high prints every informations
        -> head prints every thing except the tail
        -> tail doesn't print the head 
        -> medium only print the iterations without head or tail.
    - save_MOs & MOs_dir: if true, save the MOs at each iterations in the dir MOs_dir/
        Usefull to be able to exit stop a computation without any data loss.
    - Σ_name: name of the system appearing in the MOs files generated by save_MOs

    <><> Starting MOs
    - Φ_init: initial MOs for the computation. 
      If none are given, starting MOs are the one stored in Σ.
    - restart: if true, set the orbitals stored in Σ as the core hamiltonian guess/
""" 
function rohf_CG(Σ::ChemicalSystem;
                 Φ_init = zero(Σ.overlap_matrix),
                 ΦT_min = zero(Σ.overlap_matrix),
                 max_iter = 500,
                 max_step = one(Float64), ρ = 0.5,
                 linesearch_type = HagerZhang(),
                 cv_threshold= 1e-5,
                 verbosity = "high", save_MOs = false,
                 MOs_dir = "out",
                 Σ_name = "CG",
                 restart = false,
                 transport_type = "proj",
                 )

    (cv_threshold > 1e-4) && @warn("Warning: the convergence threshold is low and"*
                                   " will induce lower precision.")
    (typeof(max_step)≠Float64) && (max_step = Float64(max_step))
    
    tic = now()
    @assert( verbosity ∈ ("high", "head", "tail", "medium", "none") )
    @assert( transport_type ∈ ("proj", "transport") )
    
    if( verbosity ∈ ("high", "head") )
        println("Computation started at $(tic)"*"\n")
        println("Minimization of the energy on the ROHF manifold")
        (verbosity =="high") && (println("Parameters: max_iter = $max_iter, linesearch = $(linesearch_type)"))
        (verbosity =="high") &&
            (println("Stopping criteria: ||Π∇E|| < $(cv_threshold)"*"\n"));
        flush(stdout);
    end

    # Extract system's infos
    N_bds, A, S, H, atom_info = read_system(Σ)
    S12=sqrt(Symmetric(S)); Sm12=inv(S12);
    Nb,Nd,Ns = N_bds; No = Nd + Ns;
    
    # Extract initial MOs from Σ and orthogonalise.
    if( iszero(Φ_init) )
        (restart) && (reset_system!(Σ))
        Φ_init = Σ.MOs
    end
    (restart) && (reset_system!(Σ))
    ΦT = ortho_AO(Φ_init, S12)
    
    # Initial energy
    E = energy_from_MOs_T(ΦT, Sm12, A, H, N_bds, atom_info = atom_info)
    E_previous = E; ΦT_previous = ΦT;

    # Declare useful variable
    δE = 1.0; norm_grad_E = 1.0;
    iter = zero(Int64); step = zero(Float64); cos_p_∇E = zero(Float64)
    p = (zeros(Nb,Nd), zeros(Nb,Ns)); previous_norm_grad_E = zero(Float64);

    iter, computation_time = Σ.iter_and_time
    converged = false; restart_cg = true;
    
    if save_MOs
        !(isdir("$(MOs_dir)")) && (mkdir("$(MOs_dir)"))
    end
    
    # Print initial infos
    if !(verbosity == "none")
        (verbosity ∈ ("high","head")) && (println("Guess energy : $(E_previous) \n"))
        println("-"^85)
        println(@sprintf("%-16s  %-16s  %-16s %-16s %-5s  %-5s","Energy","δE",
                         "||Π∇E||","cos(p,∇E)", "Step", "Iter"))
        
        println("-"^85)
        flush(stdout)
    end

    
    
    while( !(converged) & (iter < max_iter) )
        iter += 1
        
        ΦT_next, p, previous_norm_grad_E, E,
        norm_grad_E, cos_p_∇E, step =  CG_step(ΦT, Sm12, A, H, N_bds, atom_info = atom_info,
                                               E_previous = E_previous,
                                               p_previous = p,
                                               step = step,
                                               linesearch_type = linesearch_type,
                                               ΦT_previous = ΦT_previous,
                                               max_step = max_step, ρ = ρ,
                                               previous_norm_grad_E = previous_norm_grad_E,
                                               restart_cg = restart_cg,
                                               transport = transport_type)
        # Test admissibility of MOs
        @assert( test_MOs(ΦT, N_bds) < 1e-8 )
        
        δE = E - E_previous
        E_previous = E
        ΦT_previous = ΦT; ΦT = ΦT_next;

        # Restart if the direction is not a descent dir.
        if( (cos_p_∇E > -0.05) | (iter%(No*(Nb-No))==0) )
            restart_cg = true
        else
            restart_cg = false
        end
               
        # Save_current MOs if needed
        (save_MOs) && (save_MOs_in_file(Sm12*ΦT, "$(MOs_dir)/MOs_$(Σ_name)_$(iter)";
                                        E = E, iter = iter))

        if !(verbosity == "none")
            (restart_cg) && (iter≠1) && (println("RESTART"))
            println(@sprintf("%16.12f %16.12f %16.12f %16.12f  %1.5f %5i  |  CG",
                             E, δE, norm_grad_E, cos_p_∇E, step, iter))
            flush(stdout)
        end

        if( norm_grad_E < cv_threshold )
            converged = true
        end

        # Actualize info in the ChemicalSystem structure
        Φ = Sm12*ΦT # De-orthonomalize the MOs
        Σ.MOs = Φ; Σ.E_rohf = E
        Σ.iter_and_time = (iter, computation_time)
        Σ.cv_history = (converged, norm_grad_E)

    end

    if( verbosity ∈ ("high","tail") )
        (converged)  && println("-"^85*"\n"*"CONVERGED")
        !(converged) && println("----Maximum iteration reached")
        println(@sprintf("%16.12f %16.12f %16.12f %16.12f  %1.5f %5i",
                         E, δE, norm_grad_E, cos_p_∇E,  step, iter))
        flush(stdout)
    end

    toc = now()
    computation_time += toc - tic
    
    if( verbosity ∈ ("high","tail") )
        println("\n"^2*"Process ended at $(toc)")
        println("Computation time: $(computation_time)"*"\n")
        flush(stdout)
    end
    
    Φ = Sm12*ΦT # De-orthonomalize the result
    # Store final data in the chemical system structure
    Σ.MOs = Φ; Σ.E_rohf = E
    Σ.iter_and_time = (iter, computation_time)
    Σ.cv_history = (converged, norm_grad_E)

    Σ
end
